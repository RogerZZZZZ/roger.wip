---
title: <<重构 改善既有代码的设计>>读书笔记
date: 2021-01-17 21:21:42
tags: 
  - 读书笔记
categories:
  - 读书笔记
---

## Intro

作为博客里读书笔记的第一篇文章, 算是给这个系列开一个头吧, 这里的读书比较呢主要记录的是一本书中自己觉得比较有意思的点, 写下来也是为了加深记忆, 点与点之间可能毫无逻辑可言, 大家如果读到觉得感受不是很好的话也请见谅~

## 内容

### 代码的坏味道

这里文章列举了很多代码坏味道, 比如:

- 神秘命名
- 重复代码
- 过长函数
- 过长参数列表
- 全局数据
- 可变数据
- 发散式变化
- 霰弹式修改
  - 每遇到某种变化, 都需要在不同的类中进行小修改
- 依恋情节
  - 与其他模块或者数据交流格外频繁, 甚至超过自身模块
- 数据泥团
  - 多个类中存在相同的数据字段
- 基本类型偏执
  - 执着于使用基本数据类型, 还忽略了抽象
- 重复的switch
  - 可以使用策略模式, map等方式来解决
- 循环语句
  - 多使用pipe的方式, 类似map, reduct, filter等
- 夸夸其谈的通用性
  - 这一点也是需要注意的, 虽然说在开始写代码之前都需要对系统有一个良好的设计, 但是并不意味着需要为以后的功能, 破坏现在代码的可读性, 过度抽象某些类, 需要做的应该是不断的重构优化.
- 纯数据类
  - 指一个类中没有其他的逻辑, 只有数据字段的getter以及setter
- 注释
  - 这一点在文中的说法给我留下了深刻的印象, 不应该用注释来解释阅读星极差的代码, 注释并不是"除臭剂"

接下来是一些书中提到的重构方式


### 引入参数对象

```js
function amountInvoiced(startDate, endDate)

// ====>

function amountInvoiced(dateRange)
```

配合typescript使用, 效果更佳, 在我实际开发中使用解构来获取函数参数都比过长的参数列表更加优雅, 一方面是可以省去对函数参数顺序的记忆, 另一方面是参数的传入是非常灵活的, 可以对多个参数进行默认值的设置

### 以对象取代基本类型

```js
order.filter(o => 'high' === o.priority
  || 'rush' === o.priority)

// =====>

order.filter(o => o.priority.hightThen(new Priority('normal')))
```

也许在一开始书写的时候, 第一种写法能够快速的完成需求, 但是随着业务逻辑不断复杂, 对于`priority`的判断逻辑不断增多以后, 将会逐渐失控, 如果你对Java有一定的接触, 就会很容易的联想实现`compare`的接口, 我认为都是一种理念, 对于一些数据字段进行功能的扩展

### 拆分循环

```js
let averageAge = 0
let totalSalary = 0
for (const p of people) {
  averageAge += p.age
  totalSalary = p.salary
}
averageAge /= people.length

// ======>

let averageAge = 0
for (const p of people) {
  averageAge += p.age
}
averageAge /= people.length

let totalSalary = 0
for (const p of people) {
  totalSalary = p.salary
}
```

也许下面的代码对于很多人来说都是一种坏味道, 甚至我现在也这样觉得, 因为理论上多执行了一次循环, 但是往往在很多的场景中, **循环并不是性能的瓶颈**, 分开书写之后能带来更好的维护性和可读性, 也能方便的拆分代码逻辑

### 以多态取代条件表达式

```js
switch(bird.type) {
  case 'a':
    return 'a type'
  case 'b':
    return 'b type'
  default:
    return 'default'
}

// ====>

class AType {
  getType() {
    return 'a type'
  }
}

class BType {
  getType() {
    return 'b type'
  }
}
```

### 用多态处理变体逻辑

当基类中存在对某种特殊情况进行判断计算时, 可以将这部分逻辑从中分离出来, 因为这样的特殊逻辑过多会混淆视听, 让基础的逻辑难以理解

```js
class Rating {
  constructor() {
    this.voyage = 1
  }

  getRating() {
    if (this.type === 'a') {
      return this.voyage * 2
    }
    return this.voyage
  }
}

// ====>

class Rating {
  constructor() {
    this.voyage = 1
  }

  getRating() {
    if (this.type === 'a') {
      return this.voyage * 2
    }
    return this.voyage
  }
}

class Rating {
  get getVoyageFactor() {
    return 1
  }

  getRating() {
    return this.voyage * this.getVoyageFactor()
  }
}

class ATypeRating extens Rating {
  get getVoyageFactor() {
    return 2
  }
}
```

### 将查询函数和修改函数分离

```js
function getTotalOutstandingAndSendBill() {
  const result = customer.invoices.reduce((total, each) => each.amount + total, 0)
  sendBill()
  return result;
}

// ====>

function totalOutstanding() {
  return customer.invoices.reduce((total, each) => each.amount + total, 0)
}
function sendBill() {
  sendBill()
}
```

原书中有一句话我印象深刻, 明确表现出`有副作用`与`无副作用`两种函数之间的差异, 是个很好的想法.

任何有返回值的函数, 都不应该有看得到的副作用--`命令与查询分离`

### 移除标记参数

```js
function setDimension(name, value) {
  if (name === 'height') {
    this._height = value
    return
  }
  if (name === 'width') {
    this._width = value
    return
  }
}

// =====>
function setHeight(value) {
  this._height = value
}

function setWidth(value) {
  this._width = value
}
```

我们通常在开发过程中, 经常会通过传入一些`flag`来是函数内部的逻辑进行180度的大转变, 往往这样参数的引入会让人难以理解到底那些函数可以调用, 应该如何调用, 正确的做法应该是将`flag`提取出反映在函数名上

```js
function deliveryDate(order, isRush)

// ====>

function rushDeliveryDate(order)

function regularDeliveryDate(order)
```

### 保持对象完整

```js
const { low, heigh } = dayTempRange
withinRange(low, heigh)

// ===>
withRange(dayTempRange)
```

### 以命令取代函数

```js
function score(candidate, medicalExam, scoringGuide) {
  let result = 0;
  let healthLevel = 0
  // long body code
}

// ====>
class Scorer {
  constructor(candidate, medicalExam, scoringGuide) {
    this.candidate = candidate
    this.medicalExam = medicalExam
    this.scorginGuide = scoringGuide
  }

  excute() {
    this._result = 0
    this._healthLevel = 0
    // long body code
  }
}
```

将函数封装成自己的对象, 有时也是有用的方法, 这种对象我们通常称之为`命令对象`, 这种对象通常只服务于单一函数, 获得对该函数的请求, 执行该函数, 就是这种对象存在的意义

与普通的函数相比, 命令对象有更强的表达能力以及更大的控制灵活性. 也可以命令对象增加更多的附加操作, 比如`撤销`

### 以委托取代子类

```js
class Order {
  get daysToShip() {
    return (this.priorityDelegate)
      ? this._priorityDelegate.daysToShip
      : this._warehouse.daysToShip
  }
}

class PriorityOrderDelegate {
  get daysToShip() {
    return this._priorityPlan.daysToShip
  }
}
```

这样做的原因有两个:
- 1.继承存在短板, 最明显的是, 继承只能用于处理一个方向上的变化, 比如说我们可能希望'人'的行为根据'年龄段'不同, 并根据'收入水平'不同, 使用继承的话, 子类需要有年轻人, 老人, 也可以是富人以及穷人, 但是不能同时采用两种继承方式
- 2. 继承给类之间引入了非常紧密的关系, 任何对超类上的修改, 都会对子类带来影响

## Outro

是一本值得细细思考的书, 也许之后我会每隔一年会再次翻阅, 相信到时候也会有新的感悟吧