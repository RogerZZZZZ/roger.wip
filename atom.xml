<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Work In Progress</title>
  
  
  <link href="http://rogerwip.tech/atom.xml" rel="self"/>
  
  <link href="http://rogerwip.tech/"/>
  <updated>2022-09-29T02:01:15.446Z</updated>
  <id>http://rogerwip.tech/</id>
  
  <author>
    <name>RogerZZZZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rust 开发一个简易的web服务器</title>
    <link href="http://rogerwip.tech/2021/07/11/Rust-%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://rogerwip.tech/2021/07/11/Rust-%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2021-07-11T15:04:32.000Z</published>
    <updated>2022-09-29T02:01:15.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>本章的目的呢是创建一个简单的web服务器, 本文的内容大部分来自于<code>&lt;&lt;Rust权威指南&gt;&gt;</code>.</p><a id="more"></a><h2 id="1-开始"><a href="#1-开始" class="headerlink" title="1. 开始"></a>1. 开始</h2><p>首先呢, 我们知道一个服务是启动在某一个端口上的, 那我们如何使用rust来创建一个服务监听某一个固定的端口呢. 这里我们使用到的就是<code>std::net::TcpListener</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;io::Read, net::&#123;TcpListener, TcpStream&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">handle_stream</span></span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> buffer = [<span class="number">0</span>; <span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取数据存储到缓冲区中</span></span><br><span class="line">stream.read(&amp;<span class="keyword">mut</span> buffer).unwrap();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// lossy标识会用 � 来代替无效字符</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Request: &#123;&#125;&quot;</span>, <span class="built_in">String</span>::from_utf8_lossy(&amp;buffer[..]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="comment">// 创建一个监听7878端口的服务.</span></span><br><span class="line"><span class="keyword">let</span> listener = TcpListener::bind(<span class="string">&quot;127.0.0.1:7878&quot;</span>).unwrap();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> stream <span class="keyword">in</span> listener.incoming() &#123;</span><br><span class="line"><span class="keyword">let</span> stream = stream.unwrap();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;connection established&quot;</span>);</span><br><span class="line"></span><br><span class="line">handle_stream(stream);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当我们执行<code>curl 127.0.0.1:7878</code>, 会收到以下的返回告知我们服务器并没有对此请求作出任何的返回. 所以接下来我们要补充请求的返回</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl: (52) Empty reply from server</span><br></pre></td></tr></table></figure><h3 id="返回一个HTML"><a href="#返回一个HTML" class="headerlink" title="返回一个HTML"></a>返回一个HTML</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">handle_stream</span></span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> buffer = [<span class="number">0</span>; <span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">stream.read(&amp;<span class="keyword">mut</span> buffer).unwrap();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取文件</span></span><br><span class="line"><span class="keyword">let</span> content = fs::read_to_string(<span class="string">&quot;index.html&quot;</span>).unwrap();</span><br><span class="line"><span class="keyword">let</span> response = <span class="built_in">format!</span>(<span class="string">&quot;HTTP/1.1 200 OK\r\n\r\n&#123;&#125;&quot;</span>, content);</span><br><span class="line">stream.write(response.as_bytes()).unwrap();</span><br><span class="line">stream.flush().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们可以通过访问<code>127.0.0.1:7878</code>看到一个完整的html渲染结果.</p><h3 id="如果处理不同的http请求类型"><a href="#如果处理不同的http请求类型" class="headerlink" title="如果处理不同的http请求类型"></a>如果处理不同的http请求类型</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处以get请求为例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> get = <span class="string">b&quot;GET HTTP/1.1\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> buffer.startWith(get) &#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重构一部分代码"><a href="#重构一部分代码" class="headerlink" title="重构一部分代码"></a>重构一部分代码</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">handle_stream</span></span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> ( status, filename ) = <span class="keyword">if</span> (buffer.starts_with(get)) &#123;</span><br><span class="line">    (<span class="string">&quot;HTTP/1.1 200 OK\r\n\r\n&quot;</span>, <span class="string">&quot;index.html&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">    (<span class="string">&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;</span>, <span class="string">&quot;404.html&quot;</span>)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> content = fs::read_to_string(filename).unwrap();</span><br><span class="line">  <span class="keyword">let</span> response = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&quot;</span>, status, content);</span><br><span class="line">stream.write(response.as_bytes()).unwrap();</span><br><span class="line">stream.flush().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h2&gt;&lt;p&gt;本章的目的呢是创建一个简单的web服务器, 本文的内容大部分来自于&lt;code&gt;&amp;lt;&amp;lt;Rust权威指南&amp;gt;&amp;gt;&lt;/code&gt;.&lt;/p&gt;</summary>
    
    
    
    <category term="rust" scheme="http://rogerwip.tech/categories/rust/"/>
    
    
    <category term="rust" scheme="http://rogerwip.tech/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 函数式编程指南 总结</title>
    <link href="http://rogerwip.tech/2021/07/11/JavaScript-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97-%E6%80%BB%E7%BB%93/"/>
    <id>http://rogerwip.tech/2021/07/11/JavaScript-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97-%E6%80%BB%E7%BB%93/</id>
    <published>2021-07-11T13:35:34.000Z</published>
    <updated>2022-09-29T02:01:15.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数式的意义"><a href="#函数式的意义" class="headerlink" title="函数式的意义"></a>函数式的意义</h2><p>整本书阅读下来, 我认为有三点吧:</p><ul><li>纯函数的意义, 固定输入 =&gt; 固定输出, 对于单元测试, 自动化测试友好.</li><li>复杂任务的分解, 相比于命令式来说, 代码意图更加明显, 增加可维护性.</li><li>有助于代码功能的拆分以及功能的模块化, 代码的逻辑可以用类似搭积木的方式完成.</li></ul><p>但是, 函数式优雅的同时, 性能并不优雅.</p><ul><li>过度使用柯里化, 会导致函数执行栈过深</li><li>每一次map, filter, reduce其实都遍历了一遍数组, 所有类似lodash这样的库才会对这样的链式调用或者是compose组合式调用进行优化, 合并连接在一起的map, filter函数</li></ul><a id="more"></a><h2 id="一些有意思的概念"><a href="#一些有意思的概念" class="headerlink" title="一些有意思的概念"></a>一些有意思的概念</h2><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>可以接收其他函数作为参数的js函数, 均属于一种函数类型, 高阶函数</p><blockquote><p>可以联想到React中的HOC</p></blockquote><h3 id="函数组合子"><a href="#函数组合子" class="headerlink" title="函数组合子"></a>函数组合子</h3><blockquote><p>组合子是一些可以组合其他函数, 并作为控制逻辑运行的高阶函数</p></blockquote><ol><li>identity ( I-combinator )</li></ol><p>identity组合子是返回与参数同值的函数</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">identity :: <span class="function"><span class="params">(a)</span> -&gt;</span> a</span><br></pre></td></tr></table></figure><ol start="2"><li>tap ( K-组合子 )</li></ol><blockquote><p>将无返回值的函数嵌入函数组合中, 它会将所属对象传入函数参数并返回该对象</p></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tap :: (a -&gt; *) -&gt; a -&gt; a</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> debug = R.tap(debugLog)</span><br><span class="line"><span class="keyword">const</span> isValidSsn = R.compose(debug, checkLengthSsn, debug, cleanInput);</span><br></pre></td></tr></table></figure><ol start="3"><li>alt ( OR-组合子 )</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> alt = R.curry(<span class="function">(<span class="params">func1, func2, val</span>) =&gt;</span> func1() || func2())</span><br></pre></td></tr></table></figure><ol start="4"><li>fork ( join组合子 )</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fork = <span class="function"><span class="keyword">function</span>(<span class="params">join, func1, func2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> join(func1(val), func2(val))</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数式对于执行错误的处理方式"><a href="#函数式对于执行错误的处理方式" class="headerlink" title="函数式对于执行错误的处理方式"></a>函数式对于执行错误的处理方式</h3><p>我们在实际编程的过程中, 处理错误的大多数方式为<code>try catch</code>, 而对于函数式来说, 不应该抛出异常, 理由如下</p><ol><li>难以与其他函数进行组合或者链接</li><li>违反了引用透明性, 因为抛出异常会导致函数调用出现另外的出口, 不能确保单一的可预测的返回值</li><li>违反局限性的原则, 因为用于恢复异常的代码与原始的函数调用渐行渐远, 当发生错误以后, 函数离开局部栈与环境</li></ol><p>接来下我们看下函数式如何处理错误, 首先给出一个概念<code>Functor</code></p><h4 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a><strong>Functor</strong></h4><blockquote><p>Functor只是一个可以将函数应用到它包裹的值上, 并将结果再包裹起来的数据结构</p></blockquote><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmap :: <span class="function"><span class="params">(A -&gt; B)</span> -&gt;</span> wrap<span class="function"><span class="params">(A)</span> -&gt;</span> wrap(B)</span><br><span class="line"></span><br><span class="line">接受一个从A-&gt;B的函数, 以及一个wrap(A) Functor, 然后返回包裹着结果的新Functor wrap(B)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> plus = R.curry(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line"><span class="keyword">const</span> plus3 = plus(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> two = wrap(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> five = two.fmap(plus3) <span class="comment">// wrap(5)</span></span><br><span class="line">five.map(R.indentity) <span class="comment">// -&gt; 5</span></span><br></pre></td></tr></table></figure><p>但是<code>Functor</code>本身并不知道如何处理null, 当在执行过程中出现null值的时候, 依旧会报错, 此时我们引入一个更为具体化的函数式数据结构<code>Monad</code>, 旨在安全的传递错误. 此处可以联想到<code>jQuery</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#id&#x27;</span>).width().height().attribute()....</span><br><span class="line"><span class="comment">// 就算#id不存在, 也不会导致执行错误</span></span><br></pre></td></tr></table></figure><h4 id="Maybe-Monad-Either-Monad"><a href="#Maybe-Monad-Either-Monad" class="headerlink" title="Maybe Monad / Either Monad"></a>Maybe Monad / Either Monad</h4><p>这两个概念类似, 我们就举一个例子就好. 此处以Maybe Monad为例.</p><blockquote><p>Maybe Monad侧重于整合<code>null</code>的判断逻辑, Maybe是一个包含两个具体子类型的空类型</p></blockquote><ul><li>Just(value) - 表示值容器</li><li>Nothing() - 表示要么没有值或者没有失败的附加信息, 当然, 还可以应用到Nothing上</li></ul><p>其实简单的做法就是在执行过程中, 如果存在null值, 就把wrap转为Nothing即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> safeFindObject = R.curry(<span class="function"><span class="keyword">function</span>(<span class="params">db, id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Maybe.fromNullable(find(db, id));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Maybe.prototype.fromNullable = <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a !== <span class="literal">null</span> ? <span class="keyword">new</span> Just(a) : <span class="keyword">new</span> Nothing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归和尾递归优化"><a href="#递归和尾递归优化" class="headerlink" title="递归和尾递归优化"></a>递归和尾递归优化</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial = <span class="function">(<span class="params">n, current = <span class="number">1</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * current) <span class="comment">// 函数最后一条语句是下一次递归时, 性能接近for语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果函数的最后一件事情是执行一个递归函数, 那么运行时会认为不必要保持当前的栈帧, 因为所有工作已经完成了.</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;函数式的意义&quot;&gt;&lt;a href=&quot;#函数式的意义&quot; class=&quot;headerlink&quot; title=&quot;函数式的意义&quot;&gt;&lt;/a&gt;函数式的意义&lt;/h2&gt;&lt;p&gt;整本书阅读下来, 我认为有三点吧:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;纯函数的意义, 固定输入 =&amp;gt; 固定输出, 对于单元测试, 自动化测试友好.&lt;/li&gt;
&lt;li&gt;复杂任务的分解, 相比于命令式来说, 代码意图更加明显, 增加可维护性.&lt;/li&gt;
&lt;li&gt;有助于代码功能的拆分以及功能的模块化, 代码的逻辑可以用类似搭积木的方式完成.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是, 函数式优雅的同时, 性能并不优雅.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;过度使用柯里化, 会导致函数执行栈过深&lt;/li&gt;
&lt;li&gt;每一次map, filter, reduce其实都遍历了一遍数组, 所有类似lodash这样的库才会对这样的链式调用或者是compose组合式调用进行优化, 合并连接在一起的map, filter函数&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://rogerwip.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://rogerwip.tech/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="javascript" scheme="http://rogerwip.tech/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>&lt;&lt;富爸爸穷爸爸&gt;&gt;读后感</title>
    <link href="http://rogerwip.tech/2021/07/07/%3C%E5%AF%8C%E7%88%B8%E7%88%B8%E7%A9%B7%E7%88%B8%E7%88%B8%3E%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    <id>http://rogerwip.tech/2021/07/07/%3C%E5%AF%8C%E7%88%B8%E7%88%B8%E7%A9%B7%E7%88%B8%E7%88%B8%3E%E8%AF%BB%E5%90%8E%E6%84%9F/</id>
    <published>2021-07-07T05:10:53.000Z</published>
    <updated>2022-09-29T02:01:15.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这本书可以说是出现在我的童年很多次, 到现在我也依旧很清晰的能记得家中的书架上有这么一本书, 但直到今天为止, 才下定决心把他读完, 当读完第一章以后, 心中只出现了一种感想, 就是后悔没有早些时候读完这本书.</p><p>下面我记录一些书中对我冲击力或是说引发我思考的一些点吧</p><a id="more"></a><h2 id="关于负债和资产的定义"><a href="#关于负债和资产的定义" class="headerlink" title="关于负债和资产的定义"></a>关于负债和资产的定义</h2><p>文中对我冲击最大的一点是认为房地产是一种负债, 引发了我的一些思考, 最后我搞清楚了为什么要这么说, 我认为房地产作为负债中占比很大的一部分在国内的情况更为显著. 因为租金回报率过低, 无论是身处几线城市, 每个月的租金回报都无法填补房贷. 而剩下的房贷势必会占用你的大部分现金流, 导致”老鼠赛跑”的产生, 无休无止的工作, 要求涨薪, 月初还完账单之后你会发现你的剩余支配所剩无几, 因为每个月的负债支出, 你无法放弃你的现有工作, 无法做出改变, 最终将你的大部分收入都贡献给了税收和银行利息.</p><p>“资产是能把钱放进我口袋里的东西, 不管我工作与否, 负债是把钱从口袋里取走的东西”</p><h2 id="财富的定义"><a href="#财富的定义" class="headerlink" title="财富的定义"></a>财富的定义</h2><p>我非常喜欢书中引用的一句话, “财富就是支撑一个人生存多长时间的能力, 或是说, 如果我今天停止工作, 我还能活多久”. 所以还是证实了上面所说的话, 过高的房贷只是负债而非资产.</p><h2 id="不要为钱工作-而是努力让钱为你工作"><a href="#不要为钱工作-而是努力让钱为你工作" class="headerlink" title="不要为钱工作, 而是努力让钱为你工作"></a>不要为钱工作, 而是努力让钱为你工作</h2><p>这是一个非常大的思想转变, 我们大多数人的培养方式都是努力学习, 进入好的大学, 选择好的公司以及平台, 获取相对稳定的收入, 然后过完一生, 大多数人都一直在为了升职加薪而奋斗, 而不选择通过思考钱生钱的方式到达不工作的目的, 好在我在工作的第一年就想明白了这个道理, 你的努力工作得到的加薪只是老板们给出的最低程度的好处而已, 更高的收益最终还是进入了老板们的口袋, 打工是不可能实现阶级变化的. 但这并不是说打工不好, 就像读者所说他并没有觉得富爸爸更加的优秀, 或是说穷爸爸非常的不堪, 只是这是每个人的人生选择而已, 而他选择的是富爸爸的道路, 所以在他还在打工的时候, 就已经在做一些副业, 为的就是之后不打工.</p><p>“我可负担不起”应该转变为”我要怎么买得起”, 停止抱怨, 专注, 思考并且实践.</p><h2 id="专业化也许会使你的选择面更小"><a href="#专业化也许会使你的选择面更小" class="headerlink" title="专业化也许会使你的选择面更小"></a>专业化也许会使你的选择面更小</h2><p>你对你的专业领域研究的越是细致, 你之后的选择就越是少. 所以不能停止学习, 扩大自己的优势.</p><h2 id="克服困难"><a href="#克服困难" class="headerlink" title="克服困难"></a>克服困难</h2><p>这一章也有很多很有意思的点</p><ol><li><p>财务上的不成功是因为对于他们而言亏钱所造成的痛苦远大于致富所带来的快乐</p></li><li><p>避免平均的投资, 比如将资金分散到多支基金或是股票上, 这样将会原地踏步. 不追求平衡. 集中精力</p></li><li><p>不要抱怨时代造英雄, 任何时代都有新的海浪, 当你发现一个浪花的时候, 你需要做的不是后悔, 而是找到下一个海浪. 看似最糟糕的时代实际上却是最赚钱的最佳时代</p></li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>在不久前我刚阅读完&lt;滚雪球&gt;, 在我看完&lt;富爸爸穷爸爸&gt;的第一章时, 我发现里面的很多想法其实和巴菲特的做法非常的契合 我这里也记录一下~</p><ol><li><p>不要放弃每一片雪花, 你现在划出的每一块钱, 之后都可能会变为100万</p></li><li><p>投资资产而非负债, 在滚雪球中, 作者有描述在巴菲特财产超过1个亿的时候, 他的房子仅价值3万美元, 这真是让人难以置信. 而车也只是普通的代步工具.</p></li><li><p>需要找到正确的下坡路, 才能滚出最大的雪球.</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这本书可以说是出现在我的童年很多次, 到现在我也依旧很清晰的能记得家中的书架上有这么一本书, 但直到今天为止, 才下定决心把他读完, 当读完第一章以后, 心中只出现了一种感想, 就是后悔没有早些时候读完这本书.&lt;/p&gt;
&lt;p&gt;下面我记录一些书中对我冲击力或是说引发我思考的一些点吧&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://rogerwip.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://rogerwip.tech/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>&lt;&lt;代码整洁之道&gt;&gt; 读书笔记</title>
    <link href="http://rogerwip.tech/2021/05/10/%3CClean%20Code%3E%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://rogerwip.tech/2021/05/10/%3CClean%20Code%3E%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2021-05-10T15:55:10.000Z</published>
    <updated>2022-09-29T02:01:15.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这本书断断续续终于最后还是读完了, 很多都是老生常谈的东西, 但其中不乏也有一些有意思值得记忆的点</p><p>这里就记录一下</p><a id="more"></a><h2 id="重构Args-第14章"><a href="#重构Args-第14章" class="headerlink" title="重构Args, 第14章"></a>重构Args, 第14章</h2><p>其中印象比较深刻的有:</p><ol><li><code>Exception类</code>的封装和使用</li><li><code>HashMap&lt;Character, ArgumentMarshaller&gt;</code>的实现和使用, 对ArgumentMarshaller有不同的实现, 比如<code>IntegerMarshaller</code>, <code>BooleanMarshaller</code>等, 然后不同的marshaller实现不同的get, set方法</li></ol><h2 id="第17章-味道与启发"><a href="#第17章-味道与启发" class="headerlink" title="第17章, 味道与启发"></a>第17章, 味道与启发</h2><p>大部分内容都在<code>重构-改善既有代码的设计</code>这书中有提及. 但有几个点值得在这里记录一下.</p><ol><li>选择算子参数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateWeeklyPay</span><span class="params">(<span class="keyword">boolean</span> overtime)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>调用的时候就会出现<code>calculateWeeklyPay(true)</code>, 导致阅读者非常的诧异. 这样的情况应当把函数功能进行拆分, 拆分为类似<code>straightPay</code>以及<code>overTimePay</code>两个函数</p><ol start="2"><li>掩蔽时序耦合</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dive</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line">  saturateGradient();</span><br><span class="line">  reticulateSplines();</span><br><span class="line">  diveForMoog(reason);</span><br><span class="line">  <span class="comment">// 编绳 -&gt; 织网 -&gt; 捕鱼 存在顺序关系, 但是对于阅读者来说失去了时序信息, 会导致潜在bug</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更好的写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dive</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line">  Gradient gradient = saturateGradient();</span><br><span class="line">  List&lt;Spline&gt; splines = reticulateSplines(gradient);</span><br><span class="line">  diveForMoog(splines, reason);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 强制了调用顺序</span></span><br></pre></td></tr></table></figure><ol start="3"><li>不要继承常量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HourlyEmployee</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">PayrollConstants</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PayrollConstants</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TENTHS_PRE_WEEK = <span class="number">400</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该改为静态导入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> PayrollConstants.*</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这本书断断续续终于最后还是读完了, 很多都是老生常谈的东西, 但其中不乏也有一些有意思值得记忆的点&lt;/p&gt;
&lt;p&gt;这里就记录一下&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://rogerwip.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://rogerwip.tech/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>如何写一个graphql validation模块</title>
    <link href="http://rogerwip.tech/2021/01/18/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AAgraphql-validation%E6%A8%A1%E5%9D%97/"/>
    <id>http://rogerwip.tech/2021/01/18/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AAgraphql-validation%E6%A8%A1%E5%9D%97/</id>
    <published>2021-01-18T13:40:43.000Z</published>
    <updated>2022-09-29T02:01:15.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写这篇文章的契机是因为最近项目中使用到了<code>graphql</code>, 为了防止接口出现安全问题, 就对<code>graphql</code>的<code>validation</code>进行了一点研究. 本文就不对<code>graphql</code>进行一些介绍了, 如果感兴趣的小伙伴, 可以移步到官网进行阅读<a href="https://graphql.org/">链接</a></p><a id="more"></a><h2 id="初级的防御"><a href="#初级的防御" class="headerlink" title="初级的防御"></a>初级的防御</h2><h3 id="1-关闭内省系统"><a href="#1-关闭内省系统" class="headerlink" title="1. 关闭内省系统"></a>1. 关闭内省系统</h3><p>首先我们要知道内省是什么, 内省也可以被认为是自检系统. 通过内省我们可以简单的就获取到<code>graphql</code>支持的所有查询以及查询字段的类型, 这里举一个例子, 你可以使用<code>__schema</code>来询问<code>graphql</code>有哪些类型是可用的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  __schema &#123;</span><br><span class="line">    types &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;__schema&quot;: &#123;</span><br><span class="line">      &quot;types&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Query&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Episode&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;ID&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;String&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; .....</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Int&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;__Type&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;__TypeKind&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;__Field&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类似<code>Query</code>, <code>Episode</code>这是我们再类型系统中定义的类型</li><li><code>Int</code>, <code>String</code>这样是内建的标量, 由系统提供</li><li><code>__Type</code>, <code>__TypeKind</code>这些则为内省系统中的一部分</li></ul><p>我们如何知道一个类型支持哪些字段, 而其中的字段又是什么类型呢</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  __type(name: &quot;Droid&quot;) &#123;</span><br><span class="line">    name</span><br><span class="line">    fields &#123;</span><br><span class="line">      name</span><br><span class="line">      type &#123;</span><br><span class="line">        name</span><br><span class="line">        kind</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;__type&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Droid&quot;,</span><br><span class="line">      &quot;fields&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;id&quot;,</span><br><span class="line">          &quot;type&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: null,</span><br><span class="line">            &quot;kind&quot;: &quot;NON_NULL&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;name&quot;,</span><br><span class="line">          &quot;type&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: null,</span><br><span class="line">            &quot;kind&quot;: &quot;NON_NULL&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;friends&quot;,</span><br><span class="line">          &quot;type&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: null,</span><br><span class="line">            &quot;kind&quot;: &quot;LIST&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;friendsConnection&quot;,</span><br><span class="line">          &quot;type&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: null,</span><br><span class="line">            &quot;kind&quot;: &quot;NON_NULL&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;appearsIn&quot;,</span><br><span class="line">          &quot;type&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: null,</span><br><span class="line">            &quot;kind&quot;: &quot;NON_NULL&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;primaryFunction&quot;,</span><br><span class="line">          &quot;type&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &quot;String&quot;,</span><br><span class="line">            &quot;kind&quot;: &quot;SCALAR&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>NON_NULL</code>表示是一个非空的包装, 可以通过<code>ofType</code>来获取其类型.</p><p>上面只是举了一些内省系统中几个简单的应用, 那么说到这里, 聪明的小伙伴就会发现这样的系统能给我们带来什么了, 对了, 那就是大家最讨厌的<code>文档</code>.</p><p>schema的编写本质就能生成一份完善的文档, 这里介绍一个现成的工具可以使用, <a href="https://github.com/mhallin/graphql-docs">graphql-doc</a></p><p>我们知道文档都是对内的, 如果将所有文档暴露在外势必会引起安全问题, 所以我们在生产环境中需要关闭内省系统</p><p>这里以<code>express</code>作为例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> bodyParser <span class="keyword">from</span> <span class="string">&#x27;body-parser&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; graphqlExpress &#125; <span class="keyword">from</span> <span class="string">&#x27;graphql-server-express&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> NoIntrospection <span class="keyword">from</span> <span class="string">&#x27;graphql-disable-introspection&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myGraphQLSchema = <span class="comment">// ... define or import your schema here!</span></span><br><span class="line"><span class="keyword">const</span> PORT = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// bodyParser is needed just for POST.</span></span><br><span class="line">app.use(<span class="string">&#x27;/graphql&#x27;</span>, bodyParser.json(), graphqlExpress(&#123;</span><br><span class="line">  schema: myGraphQLSchema,</span><br><span class="line">  validationRules: [ NoIntrospection ]</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.listen(PORT);</span><br></pre></td></tr></table></figure><h3 id="2-对Query的DDos防御"><a href="#2-对Query的DDos防御" class="headerlink" title="2. 对Query的DDos防御"></a>2. 对Query的DDos防御</h3><p><code>graphql</code>带给了前端方便的同时, 也为服务端带来了很多不确定性, 比如下面的<code>query</code>无限循环下去将会给服务器带来ddos攻击</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">query getBlogDDos &#123;</span><br><span class="line">  author(id: &quot;abc&quot;) &#123;</span><br><span class="line">    name                    # Depth: 1</span><br><span class="line">    blog &#123;                  # Depth: 2</span><br><span class="line">      author &#123;              # Depth: 3</span><br><span class="line">        name</span><br><span class="line">        blog &#123;              # Depth: 4</span><br><span class="line">          author &#123;          # Depth: 5</span><br><span class="line">            name</span><br><span class="line">            blog &#123;          # Depth: 6</span><br><span class="line">              author &#123;      # Depth: 7</span><br><span class="line">                name</span><br><span class="line">                blog &#123;      # Depth: 8</span><br><span class="line">                  # ......</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的场景解决方法也非常的简单, 通过<code>AST</code>分析<code>query</code>的深度并对其进行限制即可. 如果查询深度超过预设值, 则返回错误</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;errors&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Query has depth of 8, which exceeds max depth of 5&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过深度对<code>graphql</code>的query进行安全检查虽然简单, 但是也有更加明显的缺点, 如果在根节点进行大量的查询一样会造成ddos攻击, 所以我们需要引入另外的方法来对<code>query</code>进行校验.</p><h2 id="防御加固"><a href="#防御加固" class="headerlink" title="防御加固"></a>防御加固</h2><h3 id="1-查询的复杂度计算"><a href="#1-查询的复杂度计算" class="headerlink" title="1. 查询的复杂度计算"></a>1. 查询的复杂度计算</h3><p>查询复杂度的计算方式有很多种, 这里我们只举出一个例子, 首先我们假设查询一个基础类型字段的复杂度为<code>1</code>, 深度每<code>+1</code>(深度变化可能是列表也可能是自定义的数据结构), 就导致基础的倍数<code>*10</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  author(id: &quot;abc&quot;) &#123;</span><br><span class="line">    name                 # complexity: 1</span><br><span class="line">    id                   # complexity: 1 + 1</span><br><span class="line">    posts &#123;</span><br><span class="line">      title              # complexity: 1 + 1 + 1 * 10</span><br><span class="line">      id                 # complexity: 1 + 1 + 1 * 10 + 1 * 10</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述<code>query</code>的复杂度为<code>22</code>, </p><h3 id="2-校验工具实现"><a href="#2-校验工具实现" class="headerlink" title="2. 校验工具实现"></a>2. 校验工具实现</h3><p>现在进入本文的重点, 我们如何实现一个这样的校验工具呢, 首先看到对一个<code>query</code>的遍历, 我们能很容易的联想到深度优先算法, <code>graphql</code>官方也提供了这样的遍历函数方便开发者使用.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">visit</span>(<span class="params">root, visitor, keyMap</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供了enter, leave两个函数, 当进入/离开一个node会触发</span></span><br><span class="line"><span class="keyword">const</span> editedAst = visit(ast, &#123;</span><br><span class="line">  <span class="function"><span class="title">enter</span>(<span class="params">node, key, parent, path, ancestors</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">leave</span>(<span class="params">node, key, parent, path, ancestors</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然你可以指定<code>enter</code>, <code>leave</code>函数绑定的<code>node</code>类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">visit(ast, &#123;</span><br><span class="line">  Kind: &#123;</span><br><span class="line">    <span class="function"><span class="title">enter</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// enter the &quot;Kind&quot; node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">leave</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// leave the &quot;Kind&quot; node</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接下来是<code>visit</code>函数在<code>validation</code>中的实际使用方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComplexityLimitRule</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  maxCost,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">ComplexityLimit</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> visitor = <span class="keyword">new</span> ComplexityVisitor(context);</span><br><span class="line">    <span class="keyword">const</span> typeInfo = context._typeInfo || <span class="keyword">new</span> TypeInfo(context.getSchema());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      Document: &#123;</span><br><span class="line">        <span class="function"><span class="title">enter</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">          <span class="comment">// 此处的visitor为我们自定的遍历逻辑, 接下来会细讲</span></span><br><span class="line">          visit(node, visitWithTypeInfo(typeInfo, visitor));</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">leave</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> cost = visitor.getCost();</span><br><span class="line">          <span class="keyword">if</span> (cost &gt; maxCost) &#123;</span><br><span class="line">            context.reportError(</span><br><span class="line">              createError</span><br><span class="line">                ? createError(cost, node)</span><br><span class="line">                : <span class="keyword">new</span> GraphQLError(formatErrorMessage(cost), [ node ])</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里也贴上<a href="https://npmdoc.github.io/node-npmdoc-graphql/build..beta..travis-ci.org/apidoc.html#apidoc.element.graphql.visitWithTypeInfo"><code>visitWithTypeInfo</code></a>的实现</p></blockquote><p><code>ComplexityVisitor</code>的实现核心为在构造函数中申明需要遍历的<code>Node Type</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.Field = &#123;</span><br><span class="line">  enter: <span class="built_in">this</span>.enterField,</span><br><span class="line">  leave: <span class="built_in">this</span>.leaveField,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来的逻辑就非常简单了, 只需要在<code>enterField</code>和<code>leaveFiled</code>中补充相应的逻辑就好了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">enterField</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.costFactor *= <span class="built_in">this</span>.getFieldCostFactor();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.cost += <span class="built_in">this</span>.costFactor * <span class="built_in">this</span>.getFieldCost();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">leaveField</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.costFactor /= <span class="built_in">this</span>.getFieldCostFactor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还有两个函数比较重要, 一个是<code>getFieldCostFactor</code>, 这个函数的作用是当遇到嵌套结构, 例如自定义数据结构或者列表时候, 增大基础的复杂度系数. 另一个为<code>getFieldCost</code>, 这个是计算该<code>node</code>的实际cost, 并累加到总复杂度中.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以通过传入配置的方式, 改变不同node的复杂度, 定制自己的复杂度计算规则</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  scalarCost = <span class="number">1</span>,</span><br><span class="line">  objectCost = <span class="number">0</span>,</span><br><span class="line">  listFactor = <span class="number">10</span>,</span><br><span class="line">  ...injectOptions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是目前这样只能仅限于全局设置, 而不能对单个<code>query</code>进行自定义的复杂度计算, 并且对于不同field的开销肯定不同的, 于是我们可以通过拓展<code>extensions</code>的方式, 改变单一<code>field</code>或者<code>list</code>的复杂度. 例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">directive @cost(value: Int) on FIELD_DEFINITION</span><br><span class="line">directive @costFactor(value: Int) on FIELD_DEFINITION</span><br><span class="line"></span><br><span class="line">type CustomCostItem &#123;</span><br><span class="line">  expensiveField: ExpensiveItem @cost(value: 50)</span><br><span class="line">  expensiveList: [MyItem] @costFactor(value: 100)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的我们需要更改<code>getFieldCostFactor</code>以及<code>getFieldCost</code>函数的实现, 此处以<code>getFieldCost</code>为例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getFieldCost</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 当enter/leave一个node时, context会发生改变</span></span><br><span class="line">  <span class="keyword">const</span> fieldDef = <span class="built_in">this</span>.context.getFieldDef();</span><br><span class="line">  <span class="keyword">if</span> (fieldDef.extensions &amp;&amp; fieldDef.extensions.getCost) &#123;</span><br><span class="line">    <span class="keyword">return</span> fieldDef.extensions.getCost();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.getTypeCost(<span class="built_in">this</span>.context.getType());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们只需要提供出<code>getCost</code>方法将累加的复杂度结果透出. 在外层的<code>Document.leave</code>处对复杂度总和进行判断, 如果超过之前设置的阈值, 则抛出一个异常即可.</p><p>到这里我们就简单的实现了一个<code>graphql</code>的校验插件, 当然在文章前半部分提到的<code>深度判断</code>也可以用类似的方法快速实现</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>上面所说的查询复杂度计算也存在问题, 我们很难完美的实现对一个query复杂度的判断</p><p>所以这里我们还能通过<code>节流</code>的方式限制服务器处理单一<code>query</code>的次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  author(id: &quot;abc&quot;) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设执行上面查询的时间为100ms, 我们可以设置服务器处理这个查询的<code>最大服务器时间</code>为600ms, 每隔1s能够增加100ms的<code>服务器时间</code>, 如果服务器的<code>服务器时间</code>不够执行上面的查询, 则拒绝服务. 但是问题是我们需要对上面的查询时间有一个预估, 但这有可能是不准确. </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;写这篇文章的契机是因为最近项目中使用到了&lt;code&gt;graphql&lt;/code&gt;, 为了防止接口出现安全问题, 就对&lt;code&gt;graphql&lt;/code&gt;的&lt;code&gt;validation&lt;/code&gt;进行了一点研究. 本文就不对&lt;code&gt;graphql&lt;/code&gt;进行一些介绍了, 如果感兴趣的小伙伴, 可以移步到官网进行阅读&lt;a href=&quot;https://graphql.org/&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Front End" scheme="http://rogerwip.tech/categories/Front-End/"/>
    
    
    <category term="Front End" scheme="http://rogerwip.tech/tags/Front-End/"/>
    
    <category term="graphql" scheme="http://rogerwip.tech/tags/graphql/"/>
    
  </entry>
  
  <entry>
    <title>&lt;&lt;重构 改善既有代码的设计&gt;&gt;读书笔记</title>
    <link href="http://rogerwip.tech/2021/01/17/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://rogerwip.tech/2021/01/17/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-17T13:21:42.000Z</published>
    <updated>2022-09-29T02:01:15.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>作为博客里读书笔记的第一篇文章, 算是给这个系列开一个头吧, 这里的读书比较呢主要记录的是一本书中自己觉得比较有意思的点, 写下来也是为了加深记忆, 点与点之间可能毫无逻辑可言, 大家如果读到觉得感受不是很好的话也请见谅~</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="代码的坏味道"><a href="#代码的坏味道" class="headerlink" title="代码的坏味道"></a>代码的坏味道</h3><p>这里文章列举了很多代码坏味道, 比如:</p><a id="more"></a><ul><li>神秘命名</li><li>重复代码</li><li>过长函数</li><li>过长参数列表</li><li>全局数据</li><li>可变数据</li><li>发散式变化</li><li>霰弹式修改<ul><li>每遇到某种变化, 都需要在不同的类中进行小修改</li></ul></li><li>依恋情节<ul><li>与其他模块或者数据交流格外频繁, 甚至超过自身模块</li></ul></li><li>数据泥团<ul><li>多个类中存在相同的数据字段</li></ul></li><li>基本类型偏执<ul><li>执着于使用基本数据类型, 还忽略了抽象</li></ul></li><li>重复的switch<ul><li>可以使用策略模式, map等方式来解决</li></ul></li><li>循环语句<ul><li>多使用pipe的方式, 类似map, reduce, filter等</li></ul></li><li>夸夸其谈的通用性<ul><li>这一点也是需要注意的, 虽然说在开始写代码之前都需要对系统有一个良好的设计, 但是并不意味着需要为以后的功能, 破坏现在代码的可读性, 过度抽象某些类, 需要做的应该是不断的重构优化.</li></ul></li><li>纯数据类<ul><li>指一个类中没有其他的逻辑, 只有数据字段的getter以及setter</li></ul></li><li>注释<ul><li>这一点在文中的说法给我留下了深刻的印象, 不应该用注释来解释阅读性极差的代码, 注释并不是”除臭剂”</li></ul></li></ul><p>接下来是一些书中提到的重构方式</p><h3 id="引入参数对象"><a href="#引入参数对象" class="headerlink" title="引入参数对象"></a>引入参数对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">amountInvoiced</span>(<span class="params">startDate, endDate</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// ====&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">amountInvoiced</span>(<span class="params">dateRange</span>)</span></span></span><br></pre></td></tr></table></figure><p>配合typescript使用, 效果更佳, 在我实际开发中使用解构来获取函数参数都比过长的参数列表更加优雅, 一方面是可以省去对函数参数顺序的记忆, 另一方面是参数的传入是非常灵活的, 可以对多个参数进行默认值的设置</p><h3 id="以对象取代基本类型"><a href="#以对象取代基本类型" class="headerlink" title="以对象取代基本类型"></a>以对象取代基本类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">order.filter(<span class="function"><span class="params">o</span> =&gt;</span> <span class="string">&#x27;high&#x27;</span> === o.priority</span><br><span class="line">  || <span class="string">&#x27;rush&#x27;</span> === o.priority)</span><br><span class="line"></span><br><span class="line"><span class="comment">// =====&gt;</span></span><br><span class="line"></span><br><span class="line">order.filter(<span class="function"><span class="params">o</span> =&gt;</span> o.priority.hightThen(<span class="keyword">new</span> Priority(<span class="string">&#x27;normal&#x27;</span>)))</span><br></pre></td></tr></table></figure><p>也许在一开始书写的时候, 第一种写法能够快速的完成需求, 但是随着业务逻辑不断复杂, 对于<code>priority</code>的判断逻辑不断增多以后, 将会逐渐失控, 如果你对Java有一定的接触, 就会很容易的联想实现<code>compare</code>的接口, 我认为都是一种理念, 对于一些数据字段进行功能的扩展</p><h3 id="拆分循环"><a href="#拆分循环" class="headerlink" title="拆分循环"></a>拆分循环</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> averageAge = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> totalSalary = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> people) &#123;</span><br><span class="line">  averageAge += p.age</span><br><span class="line">  totalSalary = p.salary</span><br><span class="line">&#125;</span><br><span class="line">averageAge /= people.length</span><br><span class="line"></span><br><span class="line"><span class="comment">// ======&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> averageAge = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> people) &#123;</span><br><span class="line">  averageAge += p.age</span><br><span class="line">&#125;</span><br><span class="line">averageAge /= people.length</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> totalSalary = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> people) &#123;</span><br><span class="line">  totalSalary = p.salary</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许下面的代码对于很多人来说都是一种坏味道, 甚至我现在也这样觉得, 因为理论上多执行了一次循环, 但是往往在很多的场景中, <strong>循环并不是性能的瓶颈</strong>, 分开书写之后能带来更好的维护性和可读性, 也能方便的拆分代码逻辑</p><h3 id="以多态取代条件表达式"><a href="#以多态取代条件表达式" class="headerlink" title="以多态取代条件表达式"></a>以多态取代条件表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(bird.type) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;a type&#x27;</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;b type&#x27;</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;default&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AType</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">getType</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;a type&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BType</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">getType</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;b type&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用多态处理变体逻辑"><a href="#用多态处理变体逻辑" class="headerlink" title="用多态处理变体逻辑"></a>用多态处理变体逻辑</h3><p>当基类中存在对某种特殊情况进行判断计算时, 可以将这部分逻辑从中分离出来, 因为这样的特殊逻辑过多会混淆视听, 让基础的逻辑难以理解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rating</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.voyage = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getRating</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.type === <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.voyage * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.voyage</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rating</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.voyage = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getRating</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.type === <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.voyage * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.voyage</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rating</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">getVoyageFactor</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getRating</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.voyage * <span class="built_in">this</span>.getVoyageFactor()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ATypeRating</span> <span class="title">extens</span> <span class="title">Rating</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">getVoyageFactor</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将查询函数和修改函数分离"><a href="#将查询函数和修改函数分离" class="headerlink" title="将查询函数和修改函数分离"></a>将查询函数和修改函数分离</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTotalOutstandingAndSendBill</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = customer.invoices.reduce(<span class="function">(<span class="params">total, each</span>) =&gt;</span> each.amount + total, <span class="number">0</span>)</span><br><span class="line">  sendBill()</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">totalOutstanding</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> customer.invoices.reduce(<span class="function">(<span class="params">total, each</span>) =&gt;</span> each.amount + total, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendBill</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  sendBill()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原书中有一句话我印象深刻, 明确表现出<code>有副作用</code>与<code>无副作用</code>两种函数之间的差异, 是个很好的想法.</p><p>任何有返回值的函数, 都不应该有看得到的副作用–<code>命令与查询分离</code></p><h3 id="移除标记参数"><a href="#移除标记参数" class="headerlink" title="移除标记参数"></a>移除标记参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setDimension</span>(<span class="params">name, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">&#x27;height&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._height = value</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">&#x27;width&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._width = value</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =====&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setHeight</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>._height = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setWidth</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>._width = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通常在开发过程中, 经常会通过传入一些<code>flag</code>来是函数内部的逻辑进行180度的大转变, 往往这样参数的引入会让人难以理解到底那些函数可以调用, 应该如何调用, 正确的做法应该是将<code>flag</code>提取出反映在函数名上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deliveryDate</span>(<span class="params">order, isRush</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// ====&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">rushDeliveryDate</span>(<span class="params">order</span>)</span></span></span><br><span class="line"><span class="function"><span class="function"></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">regularDeliveryDate</span>(<span class="params">order</span>)</span></span></span></span><br></pre></td></tr></table></figure><h3 id="保持对象完整"><a href="#保持对象完整" class="headerlink" title="保持对象完整"></a>保持对象完整</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; low, heigh &#125; = dayTempRange</span><br><span class="line">withinRange(low, heigh)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===&gt;</span></span><br><span class="line"></span><br><span class="line">withRange(dayTempRange)</span><br></pre></td></tr></table></figure><h3 id="以命令取代函数"><a href="#以命令取代函数" class="headerlink" title="以命令取代函数"></a>以命令取代函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">score</span>(<span class="params">candidate, medicalExam, scoringGuide</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> healthLevel = <span class="number">0</span></span><br><span class="line">  <span class="comment">// long body code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scorer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">candidate, medicalExam, scoringGuide</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.candidate = candidate</span><br><span class="line">    <span class="built_in">this</span>.medicalExam = medicalExam</span><br><span class="line">    <span class="built_in">this</span>.scorginGuide = scoringGuide</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">excute</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._result = <span class="number">0</span></span><br><span class="line">    <span class="built_in">this</span>._healthLevel = <span class="number">0</span></span><br><span class="line">    <span class="comment">// long body code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将函数封装成自己的对象, 有时也是有用的方法, 这种对象我们通常称之为<code>命令对象</code>, 这种对象通常只服务于单一函数, 获得对该函数的请求, 执行该函数, 就是这种对象存在的意义</p><p>与普通的函数相比, 命令对象有更强的表达能力以及更大的控制灵活性. 也可以命令对象增加更多的附加操作, 比如<code>撤销</code></p><h3 id="以委托取代子类"><a href="#以委托取代子类" class="headerlink" title="以委托取代子类"></a>以委托取代子类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">daysToShip</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span>.priorityDelegate)</span><br><span class="line">      ? <span class="built_in">this</span>._priorityDelegate.daysToShip</span><br><span class="line">      : <span class="built_in">this</span>._warehouse.daysToShip</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityOrderDelegate</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">daysToShip</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._priorityPlan.daysToShip</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的原因有两个:</p><ul><li>继承存在短板, 最明显的是, 继承只能用于处理一个方向上的变化, 比如说我们可能希望’人’的行为根据’年龄段’不同, 并根据’收入水平’不同, 使用继承的话, 子类需要有年轻人, 老人, 也可以是富人以及穷人, 但是不能同时采用两种继承方式</li><li>继承给类之间引入了非常紧密的关系, 任何对超类上的修改, 都会对子类带来影响</li></ul><h2 id="Outro"><a href="#Outro" class="headerlink" title="Outro"></a>Outro</h2><p>是一本值得细细思考的书, 也许之后我会每隔一年会再次翻阅, 相信到时候也会有新的感悟吧</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Intro&quot;&gt;&lt;a href=&quot;#Intro&quot; class=&quot;headerlink&quot; title=&quot;Intro&quot;&gt;&lt;/a&gt;Intro&lt;/h2&gt;&lt;p&gt;作为博客里读书笔记的第一篇文章, 算是给这个系列开一个头吧, 这里的读书比较呢主要记录的是一本书中自己觉得比较有意思的点, 写下来也是为了加深记忆, 点与点之间可能毫无逻辑可言, 大家如果读到觉得感受不是很好的话也请见谅~&lt;/p&gt;
&lt;h2 id=&quot;内容&quot;&gt;&lt;a href=&quot;#内容&quot; class=&quot;headerlink&quot; title=&quot;内容&quot;&gt;&lt;/a&gt;内容&lt;/h2&gt;&lt;h3 id=&quot;代码的坏味道&quot;&gt;&lt;a href=&quot;#代码的坏味道&quot; class=&quot;headerlink&quot; title=&quot;代码的坏味道&quot;&gt;&lt;/a&gt;代码的坏味道&lt;/h3&gt;&lt;p&gt;这里文章列举了很多代码坏味道, 比如:&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://rogerwip.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://rogerwip.tech/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Git Merging vs. Rebasing</title>
    <link href="http://rogerwip.tech/2021/01/08/git%20merge%20vs%20git%20rebase/"/>
    <id>http://rogerwip.tech/2021/01/08/git%20merge%20vs%20git%20rebase/</id>
    <published>2021-01-08T05:48:15.000Z</published>
    <updated>2022-09-29T01:23:26.997Z</updated>
    
    <content type="html"><![CDATA[<p>在日常的工作中, 我已经无数次的使用git命令来管理代码仓库以及管理团队协作的问题. 但是直到今天才彻底搞清合并代码时候使用的<code>git rebase</code>以及<code>git merge</code>的区别.</p><p><img src="https://wac-cdn.atlassian.com/dam/jcr:1523084b-d05a-4f5a-bd1a-01866ec09ca3/01%20A%20forked%20commit%20history.svg?cdnVersion=547" alt="branch.png"></p><a id="more"></a><p>首先我们要知道的是<code>git rebase</code>以及<code>git merge</code>在达到的最终效果上是没有区别的, 可以说是殊途同归. 那接下来我们来看看两者在过程中的具体差异.</p><h2 id="Merging"><a href="#Merging" class="headerlink" title="Merging"></a>Merging</h2><p>当我们需要将开发分支合并到主干或者是预发布分支时, 如果使用merge命令需要切到主干/预发布分支进行操作, 多少感觉是很奇怪的, 而且相比rebase最大的区别是会多一个合并节点.</p><p><img src="https://wac-cdn.atlassian.com/dam/jcr:4639eeb8-e417-434a-a3f8-a972277fc66a/02%20Merging%20main%20into%20the%20feature%20branh.svg?cdnVersion=547" alt="merge.png"></p><h2 id="Rebasing"><a href="#Rebasing" class="headerlink" title="Rebasing"></a>Rebasing</h2><p><img src="https://wac-cdn.atlassian.com/dam/jcr:3bafddf5-fd55-4320-9310-3d28f4fca3af/03%20Rebasing%20the%20feature%20branch%20into%20main.svg?cdnVersion=547" alt="rebase.png"></p><p>功能非常的直观, 将rebase分支的commit放于你分支新commit的前面, rebase的流程是逐个commit去检查是否有冲突, 如果有会阻断rebase进程, 待你解决冲突后, <code>git rebase --continue</code>继续流程直到结束. 那<code>rebase</code>有什么好处呢</p><ul><li>history没有被破坏</li><li>没有新增多余的commit节点</li><li>不会破坏主干分支就可以多次更新主干代码</li></ul><p>当然在使用的时候需要注意的是: <strong>不要在主干分支进行rebase</strong>, 会影响到别的开发者的协同开发.</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git checkout -b temporary-branch</span><br><span class="line">git rebase -i main</span><br><span class="line"><span class="comment"># [Clean up the history]</span></span><br><span class="line">git checkout main</span><br><span class="line">git merge temporary-branch</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在日常的工作中, 我已经无数次的使用git命令来管理代码仓库以及管理团队协作的问题. 但是直到今天才彻底搞清合并代码时候使用的&lt;code&gt;git rebase&lt;/code&gt;以及&lt;code&gt;git merge&lt;/code&gt;的区别.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wac-cdn.atlassian.com/dam/jcr:1523084b-d05a-4f5a-bd1a-01866ec09ca3/01%20A%20forked%20commit%20history.svg?cdnVersion=547&quot; alt=&quot;branch.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="http://rogerwip.tech/categories/git/"/>
    
    
    <category term="git" scheme="http://rogerwip.tech/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>记一次HHKB`失联`的修复</title>
    <link href="http://rogerwip.tech/2021/01/08/%E8%AE%B0%E4%B8%80%E6%AC%A1HHKB-%E5%A4%B1%E8%81%94-%E7%9A%84%E4%BF%AE%E5%A4%8D/"/>
    <id>http://rogerwip.tech/2021/01/08/%E8%AE%B0%E4%B8%80%E6%AC%A1HHKB-%E5%A4%B1%E8%81%94-%E7%9A%84%E4%BF%AE%E5%A4%8D/</id>
    <published>2021-01-08T05:48:15.000Z</published>
    <updated>2022-09-29T02:01:15.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="随意BB几句"><a href="#随意BB几句" class="headerlink" title="随意BB几句"></a>随意BB几句</h2><p>因为电脑黑屏的关系, 用TimeMachine进行了电脑的备份和恢复, 一切的体验都非常的好直到发现<code>HHKB</code>连不上新电脑的那一刻开始..心态炸裂, 花了大概三个小时最终终于解决了…希望以后遇到这个问题的小伙伴能顺利解决</p><a id="more"></a><h2 id="正文-问题表现"><a href="#正文-问题表现" class="headerlink" title="正文: 问题表现"></a>正文: 问题表现</h2><p>键盘: <strong>HHKB Hybrid Type-s 双模版本</strong><br>电脑: <strong>macbook</strong></p><p>表现为蓝牙一直无法稳定的链接到电脑上, 无论是有线或者无线的模式, 在系统蓝牙管理页面处可以看到<code>HHKB</code>的图标一直上下闪烁, 最终无法连接成功导致键盘无法正常工作</p><p><a href="https://imgchr.com/i/sumv5D"><img src="https://s3.ax1x.com/2021/01/08/sumv5D.png" alt="sumv5D.png"></a></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>键盘开机</li><li>按住<code>Fn + Q</code>进入配对模式, 表现为蓝色的灯一直闪烁</li><li>再按住<code>Fn + Z + ~</code>键清空键盘蓝牙配对信息, 键盘会自动关闭, 灯会变成橙色</li><li>再长按开关键重新打开键盘, 按住<code>Fn + Q</code>重新进行进入配对模式</li><li>按住<code>Fn + Control + 1/2/3/4</code>, 指定1,2,3,4任意一个序号, 之后电脑重新搜索蓝牙就可以找到你刚才用的序号命名的键盘了, 再次连接<strong>键盘就恢复了</strong></li></ul><p>这里也附上我找到的关于<code>HHKB</code>蓝牙相关设置的按键组合</p><p><a href="https://imgchr.com/i/sutEdJ"><img src="https://s3.ax1x.com/2021/01/08/sutEdJ.png" alt="sutEdJ.png"></a></p><h2 id="高级操作-常规操作"><a href="#高级操作-常规操作" class="headerlink" title="高级操作(常规操作)"></a>高级操作(常规操作)</h2><p>为什么会存在设置蓝牙序号这样的操作呢, 这其实也是<code>HHKB</code>的一个feature吧, 多设备间的快速切换, 最多可以连接四台设备(包括mac, ios, windows, android), 只需要提前对四个设备设置不同的键盘编号即可. 直接按下<code>Fn + Control + 1/2/3/4</code>就可以做到秒级的设备切换, 这是<code>filco</code>之类的键盘无法做到的.</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;随意BB几句&quot;&gt;&lt;a href=&quot;#随意BB几句&quot; class=&quot;headerlink&quot; title=&quot;随意BB几句&quot;&gt;&lt;/a&gt;随意BB几句&lt;/h2&gt;&lt;p&gt;因为电脑黑屏的关系, 用TimeMachine进行了电脑的备份和恢复, 一切的体验都非常的好直到发现&lt;code&gt;HHKB&lt;/code&gt;连不上新电脑的那一刻开始..心态炸裂, 花了大概三个小时最终终于解决了…希望以后遇到这个问题的小伙伴能顺利解决&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="http://rogerwip.tech/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="其他" scheme="http://rogerwip.tech/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>用Rust写一个CLI工具</title>
    <link href="http://rogerwip.tech/2021/01/07/%E7%94%A8Rust%E5%86%99%E4%B8%80%E4%B8%AACLI%E5%B7%A5%E5%85%B7/"/>
    <id>http://rogerwip.tech/2021/01/07/%E7%94%A8Rust%E5%86%99%E4%B8%80%E4%B8%AACLI%E5%B7%A5%E5%85%B7/</id>
    <published>2021-01-07T14:25:44.000Z</published>
    <updated>2022-09-29T02:01:15.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p><strong>Lingling insurance</strong></p><p>自己刚开始学习Rust不久, 写这个简单的cli也是为了练手, 代码不优雅也请各路大神指点, 我定虚心求教! 起初接触到rust是因为WebAssembly, 有不少人用rust编译为WSAM, 作为一个合格的前端娱乐圈工作者, 还是希望对此有一定的了解. </p><p>该CLI实现一个持久化的TODO list. 那废话不多说, 咱们开始吧!</p><a id="more"></a><h2 id="1-开始"><a href="#1-开始" class="headerlink" title="1. 开始"></a>1. 开始</h2><h3 id="1-1-rust安装"><a href="#1-1-rust安装" class="headerlink" title="1.1 rust安装"></a>1.1 rust安装</h3><p>如果你是用的是Macos或者是linux都可以简单的通过下面的命令安装rust</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl &lt;https://sh.rustup.rs&gt; -sSf | sh</span><br></pre></td></tr></table></figure><p>如果你使用的window系统, 可以上<a href="https://rustup.rs/">rustup</a>下载对应exe文件.</p><h3 id="1-2-cargo的使用"><a href="#1-2-cargo的使用" class="headerlink" title="1.2 cargo的使用"></a>1.2 cargo的使用</h3><p><code>cargo</code>是<code>rust</code>包内自带的包管理工具, 类似npm, 同时也提供了一些cli来编译或者初始化一个项目</p><blockquote><p>cargo init</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 初始化一个项目</span><br><span class="line">cargo init xxx-project </span><br></pre></td></tr></table></figure><p>执行结束以后会在执行目录下生产下面的目录结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|</span><br><span class="line">  .git/</span><br><span class="line">  |</span><br><span class="line">  .gitignore</span><br><span class="line">  |</span><br><span class="line">  Cargo.toml</span><br><span class="line">  |</span><br><span class="line">  src/</span><br></pre></td></tr></table></figure><p>其中需要解释的是<code>Cargo.toml</code>文件, 其作用和<code>npm</code>中<code>package.json</code>相同, 对项目信息和包依赖进行一些说明</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;rust-cli&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;rogerjluo&quot;</span>]</span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2018&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">serde</span> = &#123; version = <span class="string">&quot;1.0&quot;</span>, features = [<span class="string">&quot;derive&quot;</span>] &#125;</span><br><span class="line"><span class="attr">clap</span> = <span class="string">&quot;~2.32&quot;</span></span><br><span class="line"><span class="attr">serde_json</span> = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"><span class="attr">chrono</span> = <span class="string">&quot;0.4&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>cargo build</p></blockquote><p>改命令是将项目进行预编译, 安装你在toml文件中的依赖至<code>target</code>文件夹内, 并生成或者更新<code>Cargo.lock</code>文件对依赖的版本进行管理(作用类似package-lock.json).</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br><span class="line">   Compiling proc-macro2 v1.0.24</span><br><span class="line">   Compiling autocfg v1.0.1</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">   Compiling chrono v0.4.19</span><br><span class="line">   Compiling rust-cli v0.1.0 (/Users/rogerjluo/Documents/project/rust-cli)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 28.25s</span><br></pre></td></tr></table></figure><blockquote><p>cargo run build</p></blockquote><p>编译后执行二进制文件, 比如在<code>src/main.rs</code>文件中写入</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span> </span>() &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cargo run build</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.03s</span><br><span class="line">     Running `target/debug/rust-cli build`</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><h2 id="2-文件存储和读取"><a href="#2-文件存储和读取" class="headerlink" title="2. 文件存储和读取"></a>2. 文件存储和读取</h2><p>因为我们要做一个持久化数据的todolist, 所以文件操作是必不可少的, 这里就用到了标准库中的<code>std::io::&#123;Read, Write&#125;</code>以及<code>std::fs</code>.</p><p>首先我们需要声明一些<code>struct</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InternalFile</span></span> &#123;</span><br><span class="line">  path: <span class="built_in">String</span>,</span><br><span class="line">  <span class="keyword">pub</span> data: <span class="built_in">String</span>,</span><br><span class="line">  <span class="keyword">pub</span> actual_size: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">FileSystem</span></span> &#123;</span><br><span class="line">  files: HashMap&lt;<span class="built_in">String</span>, InternalFile&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>写文件</p></blockquote><p>这里使用HashMap的原因是不希望多次写文件, 所以将多次写入操作合并之后再写入.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将写入数据先写入到内存中</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">write</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, path: &amp;<span class="built_in">str</span>, data: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">  <span class="keyword">self</span>.files.insert(</span><br><span class="line">    calculate_hash(&amp;path.to_string().as_bytes()),</span><br><span class="line">    InternalFile &#123;</span><br><span class="line">      path: path.to_string(),</span><br><span class="line">      data: data.to_string(),</span><br><span class="line">      actual_size: data.len(),</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件系统数据转存到文件</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">save</span></span>&lt;T: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(&amp;<span class="keyword">self</span>, path: T) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> f = fs::File::create(&amp;path).unwrap();</span><br><span class="line">  <span class="keyword">for</span> (_, file) <span class="keyword">in</span> &amp;<span class="keyword">self</span>.files &#123;</span><br><span class="line">    f.write(&amp;file.data.as_bytes()).unwrap();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>读文件</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">load</span></span>(&amp;<span class="keyword">self</span>, path: <span class="built_in">String</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> path_name = Path::new(&amp;path);</span><br><span class="line">  <span class="keyword">let</span> display = path_name.display();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> file = <span class="keyword">match</span> File::open(&amp;path_name) &#123;</span><br><span class="line">    <span class="literal">Ok</span>(file) =&gt; file,</span><br><span class="line">    <span class="literal">Err</span>(_why) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 如果文件不存在则创建一个文件</span></span><br><span class="line">      <span class="keyword">self</span>.save(path);</span><br><span class="line">      <span class="built_in">panic!</span>(<span class="string">&quot;文件不存在, 已经新建存储文件, 请重试&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">  <span class="keyword">match</span> file.read_to_string(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">    <span class="literal">Err</span>(why) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;无法打开文件 &#123;&#125;: &#123;&#125;&quot;</span>, display,</span><br><span class="line">    why.to_string()),</span><br><span class="line">    <span class="literal">Ok</span>(_) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&quot;</span>),</span><br><span class="line">  &#125;</span><br><span class="line">  s <span class="comment">// 返回文件内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-JSON的序列化和反序列化"><a href="#3-JSON的序列化和反序列化" class="headerlink" title="3. JSON的序列化和反序列化"></a>3. JSON的序列化和反序列化</h2><p>当然为了方便对文件内容进行操作, 我们对写入和读取进行了序列化和反序列的过程, 使用到的是<code>serde_json</code>, 实现类似JS中的<code>JSON.parse</code>以及<code>JSON.stringify</code></p><blockquote><p>序列化</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serde_json::to_string(TodoList)</span><br></pre></td></tr></table></figure><blockquote><p>反序列化</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data: TodoList = <span class="keyword">match</span> serde_json::from_str(&amp;file) &#123;</span><br><span class="line">  <span class="literal">Ok</span>(x) =&gt; x,</span><br><span class="line">  <span class="literal">Err</span>(_why) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 如果文件为空或者出错, 则创建一个空的list返回</span></span><br><span class="line">    TodoList &#123;</span><br><span class="line">      todos: HashMap::new(),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里我们是可以指定反序列化的目标结构, 如果结构不匹配则无法完成反序列化, 但是前提是需要在<code>struct</code>上加上一些声明</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> serde::&#123;Deserialize, Serialize&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Serialize, Deserialize)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TodoTask</span></span> &#123;</span><br><span class="line">  content: <span class="built_in">String</span>,</span><br><span class="line">  is_done: <span class="built_in">bool</span>,</span><br><span class="line">  c_time: <span class="built_in">String</span>,</span><br><span class="line">  u_time: <span class="built_in">String</span>,</span><br><span class="line">  index: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Serialize, Deserialize)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TodoList</span></span> &#123;</span><br><span class="line">  <span class="keyword">pub</span> todos: HashMap&lt;<span class="built_in">String</span>, <span class="built_in">Vec</span>&lt;TodoTask&gt;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-clap"><a href="#4-clap" class="headerlink" title="4. clap"></a>4. clap</h2><p>基础的功能有了, 接下来我们需要获取命令行中传入的参数并执行不同的逻辑, <code>cargo</code>中 <code>cargo run -- [参数]</code>可以将参数传入到程序中, 但我们这里将使用一个叫做<code>clap</code>的库来简化这个过程.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> help_instru = r#<span class="string">&quot;命令名:</span></span><br><span class="line"><span class="string">    add(a)          -p [Content]                  : 添加当天的todo</span></span><br><span class="line"><span class="string">    list_all(la)                                  : 打印全部todo</span></span><br><span class="line"><span class="string">    list_daily(ld)  -p [Date: YYYY-MM-DD]         : 打印某一天的todo, 不带参数默认打印当天</span></span><br><span class="line"><span class="string">    remove(rm)      -p [Date: YYYY-MM-DD] [Index] : 删除某一项todo</span></span><br><span class="line"><span class="string">    toggle(t)       -p [Date: YYYY-MM-DD] [Index] : 改变某一项todo的状态, 完成/待完成</span></span><br><span class="line"><span class="string">    list_week(lw)   -p [Date: YYYY-MM-DD]         : 打印某一周的todo, 方便生成周报</span></span><br><span class="line"><span class="string">  &quot;</span>#;</span><br><span class="line">  <span class="keyword">let</span> matches = App::new(<span class="string">&quot;Todo&quot;</span>)</span><br><span class="line">    .version(<span class="string">&quot;0.0.1&quot;</span>)</span><br><span class="line">    .author(<span class="string">&quot;rogerjluo&quot;</span>)</span><br><span class="line">    .about(<span class="string">&quot;rust实现的todolist&quot;</span>)</span><br><span class="line">    .arg(Arg::with_name(<span class="string">&quot;MODE&quot;</span>)</span><br><span class="line">      .short(<span class="string">&quot;m&quot;</span>)</span><br><span class="line">      .long(<span class="string">&quot;mode&quot;</span>)</span><br><span class="line">      .takes_value(<span class="literal">true</span>)</span><br><span class="line">      .help(help_instru))</span><br><span class="line">    .arg(Arg::with_name(<span class="string">&quot;PARAMETERS&quot;</span>)</span><br><span class="line">      .short(<span class="string">&quot;p&quot;</span>)</span><br><span class="line">      .long(<span class="string">&quot;params&quot;</span>)</span><br><span class="line">      .multiple(<span class="literal">true</span>)</span><br><span class="line">      .takes_value(<span class="literal">true</span>)</span><br><span class="line">      .help(<span class="string">&quot;参数&quot;</span>))</span><br><span class="line">    .get_matches();</span><br></pre></td></tr></table></figure><p>进行了声明之后, 我们如何在程序中获取到传入的参数呢</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是参数只支持单个value, 此处match的名字与之前声明的Arg::with_name(&quot;MODE&quot;)对应</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(mode) = matches.value_of(<span class="string">&quot;MODE&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">match</span> mode &#123;</span><br><span class="line">    <span class="string">&quot;add&quot;</span> =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;list_all&quot;</span> =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;没有此命令&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持multiple value</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(params) = matches.values_of(<span class="string">&quot;PARAMETERS&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> p_list: <span class="built_in">Vec</span>&lt;&amp;<span class="built_in">str</span>&gt; = params.collect();</span><br><span class="line">  <span class="keyword">let</span> date = p_list[<span class="number">0</span>]; <span class="comment">// 参数一</span></span><br><span class="line">  <span class="keyword">let</span> index = p_list[<span class="number">1</span>]; <span class="comment">// 参数二</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;请输入参数: -p [Date: YYYYMMDD] [Index] \n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-举个栗子-🌰"><a href="#5-举个栗子-🌰" class="headerlink" title="5. 举个栗子 🌰"></a>5. 举个栗子 🌰</h2><p>这里我们只列举其中的两个具体实现~ 如果感兴趣可以去仓库中查看别的代码, 代码地址在文末.</p><blockquote><p>写入一项todo</p></blockquote><p>这里我们只写入当天的todo, 所以传入的参数只需要写入的内容即可, 命令为: <code>cargo run -- -m add -p HelloWorld</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;add&quot;</span> =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(params) = matches.values_of(<span class="string">&quot;PARAMETERS&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p_list: <span class="built_in">Vec</span>&lt;&amp;<span class="built_in">str</span>&gt; = params.collect();</span><br><span class="line">    <span class="keyword">let</span> content = p_list[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// add_task的作用就是将新的todo插入到对应日期的todo列表中, 这里就不列举代码了</span></span><br><span class="line">    <span class="keyword">let</span> newlist = task::add_task(data, content.to_string());</span><br><span class="line">    file_system.write(<span class="string">&quot;todo&quot;</span>, &amp;serde_json::to_string(&amp;TodoList &#123;</span><br><span class="line">      todos: newlist</span><br><span class="line">    &#125;).unwrap());</span><br><span class="line">    file_system.save(file_name);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;请输入参数: -p [Content] \n&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>执行后, 我们会看到指定写入文件内会有下面的信息</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;todos&quot;</span>:&#123;<span class="attr">&quot;2020-12-12&quot;</span>:[&#123;<span class="attr">&quot;content&quot;</span>:<span class="string">&quot;HelloWorld&quot;</span>,<span class="attr">&quot;is_done&quot;</span>:<span class="literal">false</span>,<span class="attr">&quot;c_time&quot;</span>:<span class="string">&quot;2020-12-12 07:21:31&quot;</span>,<span class="attr">&quot;u_time&quot;</span>:<span class="string">&quot;2020-12-12 07:21:31&quot;</span>,<span class="attr">&quot;index&quot;</span>:<span class="string">&quot;0&quot;</span>&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>列举某一天所在周的全部todo</p></blockquote><p>我们要实现这个功能, 需要计算出某一日期所在的周在该年中的index, 这里借助了<code>chrono</code>库提供的api实现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> chrono::prelude::*;</span><br><span class="line"><span class="keyword">use</span> chrono::&#123;NaiveDate&#125;;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_weekday_index</span></span>(date: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> utc = NaiveDate::parse_from_str(date, <span class="string">&quot;%Y-%m-%d&quot;</span>).unwrap();</span><br><span class="line">  <span class="comment">// utc.ordinal()可以获取日期在该年中的index</span></span><br><span class="line">  <span class="keyword">let</span> day_index = utc.ordinal();</span><br><span class="line">  (day_index / <span class="number">7</span>) + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;list_week&quot;</span> | <span class="string">&quot;lw&quot;</span> =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> date;</span><br><span class="line">  <span class="comment">// 这里判断是否传入日期参数, 没有传入默认为当天</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(params) = matches.values_of(<span class="string">&quot;PARAMETERS&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p_list: <span class="built_in">Vec</span>&lt;&amp;<span class="built_in">str</span>&gt; = params.collect();</span><br><span class="line">    date = p_list[<span class="number">0</span>].to_string();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    date = util::get_cur_ymd();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> week_index = util::get_weekday_index(&amp;date);</span><br><span class="line">  <span class="keyword">for</span> val <span class="keyword">in</span> data.todos.keys() &#123;</span><br><span class="line">    <span class="keyword">let</span> c_week_index = util::get_weekday_index(val);</span><br><span class="line">    <span class="comment">// 判断是否在同一周, 如果是则打印</span></span><br><span class="line">    <span class="keyword">if</span> c_week_index == week_index &#123;</span><br><span class="line">      task::list_daily(&amp;data, val.to_string());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>执行命令为: <code>cargo run -- -m lw</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cargo run -- -m lw               </span><br><span class="line">   Compiling rust-cli v0.1.0 (/Users/rogerjluo/Documents/project/rust-cli)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 2.00s</span><br><span class="line">     Running `target/debug/rust-cli -m lw`</span><br><span class="line"></span><br><span class="line">2020-12-12:</span><br><span class="line"></span><br><span class="line">0. [Need Handle] HelloWorld</span><br></pre></td></tr></table></figure><h2 id="6-结尾"><a href="#6-结尾" class="headerlink" title="6. 结尾"></a>6. 结尾</h2><p>文章只是介绍了项目中的部分代码以及功能, 完整版已经实现的功能包括:</p><ul><li>写入新的todo</li><li>更改todo状态, 待处理和已完成间进行切换</li><li>删除某个todo</li><li>列出所有todo</li><li>列出本周的todo list</li><li>列出某一天的todo list</li></ul><p>(这里没有列出所有的代码, 如果你感兴趣, 请移步到: <a href="https://github.com/RogerZZZZZ/rust-todo-cli">git</a>) 如果觉得还不错, 帮忙点个star吧, 初学者举步维艰</p><p>如果大家对代码有什么建议的话希望能告诉我, 这将继续鞭策我前进, 感谢~</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Lingling insurance&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自己刚开始学习Rust不久, 写这个简单的cli也是为了练手, 代码不优雅也请各路大神指点, 我定虚心求教! 起初接触到rust是因为WebAssembly, 有不少人用rust编译为WSAM, 作为一个合格的前端娱乐圈工作者, 还是希望对此有一定的了解. &lt;/p&gt;
&lt;p&gt;该CLI实现一个持久化的TODO list. 那废话不多说, 咱们开始吧!&lt;/p&gt;</summary>
    
    
    
    <category term="rust" scheme="http://rogerwip.tech/categories/rust/"/>
    
    <category term="瞎折腾" scheme="http://rogerwip.tech/categories/rust/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="rust" scheme="http://rogerwip.tech/tags/rust/"/>
    
    <category term="cli" scheme="http://rogerwip.tech/tags/cli/"/>
    
  </entry>
  
</feed>
